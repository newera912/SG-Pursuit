package edu.albany.cs.base;

import org.apache.commons.math3.distribution.BinomialDistribution;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.Random;
import java.util.Set;

/**
 * Created by baojian on 1/16/17.
 * Email: bzhou6@albany.edu
 */
public class RandomWalk implements Serializable {

    transient private ArrayList<ArrayList<Integer>> arr;

    public int numOfNodesInT;
    public ArrayList<Edge> subGraph;
    public Set<Integer> nodesInSubGraph;
    public int iteration;

    public RandomWalk(ArrayList<ArrayList<Integer>> arr, int numOfNodesInT) {
        this.arr = arr;
        this.numOfNodesInT = numOfNodesInT;
        subGraph = run();
    }

    public RandomWalk(ArrayList<ArrayList<Integer>> arr, int numOfNodesInT, int iteration){
        this.arr = arr;
        this.numOfNodesInT = numOfNodesInT;
        this.iteration = iteration;
        subGraph = run(iteration);
    }

    private ArrayList<Edge> run() {

        ArrayList<Edge> trueSubGraph = new ArrayList<>();
        Random random = new Random();
        int start = random.nextInt(arr.size());
        int size = numOfNodesInT;
        HashSet<Integer> h = new HashSet<>();
        h.add(start);
        int count = 0;
        while (h.size() < size) {
            int next = arr.get(start).get(random.nextInt(arr.get(start).size()));
            h.add(next);
            trueSubGraph.add(new Edge(start, next, count++, 1.00000));
            start = next;
        }
        ArrayList<Edge> reducedTreEdges = new ArrayList<>();
        for (Edge edge : trueSubGraph) {
            if (!checkExist(reducedTreEdges, edge)) {
                reducedTreEdges.add(edge);
            }
        }
        this.nodesInSubGraph = h;
        return reducedTreEdges;
    }

    /**
     * check the edge exists in the trueSubGraph
     *
     * @param trueSubGraph
     * @param edge
     * @return true if this edge contains in trueSubGraph else will return false
     */
    private boolean checkExist(ArrayList<Edge> trueSubGraph, Edge edge) {
        if (trueSubGraph.isEmpty()) {
            return false;
        }
        for (Edge ed : trueSubGraph) {
            if ((ed.i == edge.i && ed.j == edge.j) || (ed.i == edge.j && ed.j == edge.i)) {
                return true;
            }
        }
        return false;
    }

    /**
     * get number of nodes using the random walk algorithm
     *
     * @param iterations
     *            the number of true nodes in the random walk algorithm
     * @return the edges generated by the random walk algorithm
     */
    private ArrayList<Edge> run(int iterations) {
        System.out.println("Random Walk Running.....");
        double minCut = Double.MAX_VALUE;
        ArrayList<Edge> bestTrueSubGraph = null;
        for (int i = 0; i < iterations; i++) {
            ArrayList<Edge> trueSubGraph = new ArrayList<Edge>();
            Random random = new Random();
            int start = random.nextInt(arr.size());
            int size = numOfNodesInT;
            HashSet<Integer> h = new HashSet<Integer>();
            h.add(start);
            int count = 0;
            int initialStart = start;
            while (h.size() < size) {
                int randomNeibIndex = random.nextInt(arr.get(start).size());
                int next = arr.get(start).get(randomNeibIndex);
                if (h.contains(next)) {
                } else {
                    h.add(next);
                    trueSubGraph.add(new Edge(start, next, count++, 1.0D));
                }
                BinomialDistribution bi = new BinomialDistribution(1, 0.1D);
                if (bi.sample() == 1) {
                    start = initialStart;
                } else {
                    start = next;
                }
            }
            if (trueSubGraph.size() != (h.size() - 1)) {
                System.out.println("random walk must be wrong... ");
                System.exit(0);
            }
            double cut = getGraphCut(h, arr);
            if (cut < minCut) {
                System.out.println("current best cut: " + cut);
                minCut = cut;
                bestTrueSubGraph = trueSubGraph;
            }
        }
        return bestTrueSubGraph;
    }

    private double getGraphCut(HashSet<Integer> trueSubGraph, ArrayList<ArrayList<Integer>> arr) {
        double cut = 0.0D;
        for (int i : trueSubGraph) {
            for (int j : arr.get(i)) {
                if (!trueSubGraph.contains(j)) {
                    /** we suppose weight of each edge is 1.0D */
                    cut += 1.0D;
                }
            }
        }
        return cut;
    }

}
