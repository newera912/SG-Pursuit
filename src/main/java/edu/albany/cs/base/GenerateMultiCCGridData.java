package edu.albany.cs.base;

import org.apache.commons.lang3.ArrayUtils;
import org.apache.commons.math3.distribution.NormalDistribution;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Random;

public class GenerateMultiCCGridData {

	
	
	public GenerateMultiCCGridData(String[] args) {

	}

	
	
	public void generateMultiGridData(int numTrueNodes, int numOfNodes,int numFestures,int[] trueFeat,double mu, double noiseLevel,
			String outPutFileName, boolean flag) throws IOException {

		// usedAlgorithm, dataSource, edges,tredges, PValue, fileName
		int numOfCCInTrueSubGraph=2;
		String usedAlgorithm = "NULL";
		String dataSource = "MultiGridDataset";
		String[] attributeNames=new String[]{"W1..WP"};
		GenerateSingleGrid g = new GenerateSingleGrid(numOfNodes);
		ArrayList<Edge> treEdges=null;
		int[] trueNodes = null;
		int ccNo=0;
		ConnectedComponents cc = new ConnectedComponents(g.adj);
		do{
			trueNodes = null;
			treEdges = multiRandomWalk(g.adj, numTrueNodes, numOfCCInTrueSubGraph);
			for (Edge e : treEdges) {
						
						if (!ArrayUtils.contains(trueNodes, e.i)) {
							trueNodes = ArrayUtils.add(trueNodes, e.i);
						}
						if (!ArrayUtils.contains(trueNodes, e.j)) {
							trueNodes = ArrayUtils.add(trueNodes, e.j);
						}
					}
			ccNo=cc.computeCCSubGraph(trueNodes);
		System.out.println(numTrueNodes+" "+ numOfCCInTrueSubGraph+" --> number of connected components is : " + ccNo);
		}while(ccNo!=2);
        
       
		double[][] PValue = new double[numFestures][g.numOfNodes];
		
		//Arrays.fill(PValue, 1.0);
		
		System.out.println(ArrayUtils.toString(trueNodes)+" "+PValue.length+" "+PValue[0].length);
		System.out.println(ArrayUtils.toString(trueFeat));
		
		for(int i=0;i<PValue.length;i++){//10
			for(int j=0;j<PValue[0].length;j++){//100
				if(Arrays.asList(ArrayUtils.toObject(trueNodes)).contains(j) && Arrays.asList(ArrayUtils.toObject(trueFeat)).contains(i)){
					PValue[i][j]=new NormalDistribution(mu, 1.0D).sample();					
				}else{
					PValue[i][j]=new NormalDistribution(0, 1.0D).sample();
				}
			}
		}

		APDMInputFormat.generateAPDMFile(usedAlgorithm, dataSource, g.edges, treEdges,outPutFileName,attributeNames,numFestures,"",PValue);
	}
	/**
	 * get number of nodes using the random walk algorithm
	 * 
	 * @param arr
	 *            the graph adjacency list
	 * @param numTrueNodes
	 *            the number of true nodes in the random walk algorithm
	 * @return the edges generated by the random walk algorithm
	 */
	public static ArrayList<Edge> multiRandomWalk(ArrayList<ArrayList<Integer>> arr, int numTrueNodes, int numOfCCInTrueSubGraph) {

        ArrayList<Edge> trueSubGraph = new ArrayList<Edge>();
        int numCC = numTrueNodes / numOfCCInTrueSubGraph;
        ArrayList<Edge> reducedTreEdges = new ArrayList<Edge>();
        for (int i = 0; i < numOfCCInTrueSubGraph; i++) {
            Random random = new Random();
            int start = random.nextInt(arr.size());
            int size = numCC;
            HashSet<Integer> h = new HashSet<Integer>();
            h.add(start);
            int count = 0;
            while (h.size() < size) {
                int next = arr.get(start).get(random.nextInt(arr.get(start).size()));
                h.add(next);
                trueSubGraph.add(new Edge(start, next, count++, 1.00000));
                start = next;
            }
            for (Edge edge : trueSubGraph) {
                if (!checkExist(reducedTreEdges, edge)) {
                    reducedTreEdges.add(edge);
                }
            }
        }
        return reducedTreEdges;
    }
	

	/**
	 * check the edge exists in the trueSubGraph
	 * 
	 * @param trueSubGraph
	 * @param edge
	 * @return true if this edge contains in trueSubGraph else will return false
	 */
    public static boolean checkExist(ArrayList<Edge> trueSubGraph, Edge edge) {
        if (trueSubGraph.isEmpty()) {
            return false;
        }
        for (Edge ed : trueSubGraph) {
            if ((ed.i == edge.i && ed.j == edge.j) || (ed.i == edge.j && ed.j == edge.i)) {
                return true;
            }
        }
        return false;
    }

	
	
	public void genMultiGridData() throws IOException {
		//int graphSize = 100;
		int numOfTrueNodes = 10;
		int numOfFeatures=10;
		double noiseLevel = 0.0D;
		int[] trueFeat=new int[]{0,1,2,3,4};
		//double mu=0.5D;
		for(int graphSize:new int[]{100}){//100,400,900,1600,2500}){
			for(double mu:new double[]{0.5,1.0,2.0,3.0,5.0,7.0,10.0}){
				for(int truSize:new int[]{10,15,20}){	
					for(int i=0;i<100;i++){
						String root = "data/SimulationData/multiCC/truesub_"+truSize+"/multiGridData_mu"+mu;
						if (!new File(root).exists()) {
							new File(root).mkdirs();
						}
						String fileName="/APDM-GridData-" + graphSize
								+ "-precen-0.1-noise_" + noiseLevel + "-"+i+".txt";
						
						String outputFileName = root+fileName;
						//int numTrueNodes, int numOfNodes,int numFestures, double noiseLevel,String outPutFileName, boolean flag
						generateMultiGridData(numOfTrueNodes, graphSize,numOfFeatures,trueFeat,mu, noiseLevel, outputFileName, false);
						
						//testTrueSubGraph(outputFileName);
					}
				}
			}
		}
	}
	
	public void testTrueSubGraph(String fileName) {
		APDMInputFormat apdm = new APDMInputFormat(fileName);
		System.out.println(apdm.data.trueSubGraphNodes.length);
		ConnectedComponents cc = apdm.data.cc;
		System.out.println(cc.computeCCSubGraph(apdm.data.trueSubGraphNodes));
	}

	public static void main(String args[]) throws IOException {
		new GenerateMultiCCGridData(args).genMultiGridData();
	}
}
